package generator

import (
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
)

// WriteCommonTypes schreibt common.go mit gemeinsamen Type-Definitionen
func WriteCommonTypes(outputPath string) error {
	tmpl := `// Code generated by sde-schema-gen
// DO NOT EDIT manually

package types

// LocalizedText repräsentiert mehrsprachige Texte im EVE SDE
type LocalizedText struct {
	De string ` + "`json:\"de,omitempty\"`" + `
	En string ` + "`json:\"en\"`" + `
	Es string ` + "`json:\"es,omitempty\"`" + `
	Fr string ` + "`json:\"fr,omitempty\"`" + `
	Ja string ` + "`json:\"ja,omitempty\"`" + `
	Ko string ` + "`json:\"ko,omitempty\"`" + `
	Ru string ` + "`json:\"ru,omitempty\"`" + `
	Zh string ` + "`json:\"zh,omitempty\"`" + `
}
`
	return os.WriteFile(outputPath, []byte(tmpl), 0644)
}

// WriteGoFile generiert eine .go-Datei aus einem Schema
func WriteGoFile(outputPath, typeName string, schema *Schema, sourceFile string) error {
	// Template für Go-Struct
	tmplStr := `// Code generated by sde-schema-gen from JSONL data analysis
// DO NOT EDIT manually - regenerate with: sde-schema-gen
// Source: {{ .SourceFile }}

package types

// {{ .TypeName }} represents the schema for {{ .SourceFile }}
type {{ .TypeName }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }} ` + "`json:\"{{ .JSONTag }}{{ if not .Required }},omitempty{{ end }}\"`" + `
{{- end }}
}
`

	// Bereite Template-Daten vor
	type FieldData struct {
		Name     string
		Type     string
		JSONTag  string
		Required bool
	}

	type TemplateData struct {
		TypeName         string
		SourceFile       string
		HasLocalizedText bool
		Fields           []FieldData
	}

	data := TemplateData{
		TypeName:   typeName,
		SourceFile: sourceFile,
		Fields:     make([]FieldData, 0, len(schema.Fields)),
	}

	// Konvertiere Fields zu sortierten Slice
	fieldNames := make([]string, 0, len(schema.Fields))
	for name := range schema.Fields {
		fieldNames = append(fieldNames, name)
	}
	sort.Strings(fieldNames)

	// Generiere Field-Daten
	for _, jsonName := range fieldNames {
		field := schema.Fields[jsonName]

		// CamelCase für Go-Feldnamen
		goName := ToCamelCase(jsonName, true)

		// Type
		goType := field.GoType
		if field.IsLocalized {
			goType = "LocalizedText"
		}

		// _key ist immer required (primary key)
		isRequired := field.IsRequired || jsonName == "_key"

		data.Fields = append(data.Fields, FieldData{
			Name:     goName,
			Type:     goType,
			JSONTag:  jsonName,
			Required: isRequired,
		})
	}
	// Render Template
	tmpl, err := template.New("struct").Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("template parse error: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("template execute error: %w", err)
	}

	// Schreibe Datei
	return os.WriteFile(outputPath, []byte(buf.String()), 0644)
}
